操作系统
计算机 | 笔记 | 操作系统
操作系统是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。 操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。 操作系统也提供一个让用户与系统交互的操作界面。
2019-9-7



计算机系统：基本构成、寄存器、指令执行、中断、存储器的层次结构、高速缓冲存储器、I/O 通信技术

## 操作系统（概念）

------

1. 目标：方便性、有效性、扩展能力
2. 串行、批处理（JCL，硬件特征，内存保护）
3. 多道程序设计（兼容的分时系统）
4. 成就：进程（程序，数据，上下文）、内存管理，信息保护安全（可用，保密，完整【即不被修改】，认证）、调度（公平，有差别，效率）、系统结构
5. 难点：不正确同步，失败的互斥，不确定的操作，死锁
6. 内存：隔离，自动分配，模块化设计，保护 / 访问，长期存储 
   1. 虚拟内存：逻辑角度，文件系统
   2. 分页：页号 + 页内偏移
7. 现代操作系统特征（微内核，多线程，对称多处理器，分布式操作系统，面向对象设计）
8. Windows 内核模式组建，UNIX 的一般体系结构
9. 现代 OS 的基本特征：并发、共享、虚拟、异步

## 进程描述和控制

------

1. 顺序执行：顺序性、封闭性、可再现性
2. 并发：间断性、失去封闭性、不可再现性
3. 进程：正在执行的程序、程序实例、实体、资源集合
4. PCB（进程控制块）：标示符、状态、优先级、PC、内存指针、上下文数据、I/O 状态信息、审计信息（作用：包括进程的各个要素，是进程描述的数据结构，一个 PCB 可以代表一个进程，由操作系统进行创建和管理，运行多个进程同时执行） 
   1. 大体可以分为三类：标示号、状态信息、控制信息
   2. 组织管理：线性、索引、链接
5. 概念：程序：指令集合；作业：给予计算机的任务（一个作业总是由一个以上的进程）；进程：程序和数据发生的活动
6. 程序与进程的区别： 
   1. 动态与静态
   2. 生存期（进程是暂时的，程序是永久的）
   3. 一个程序可能对应多个进程，一个进程可以执行一个或多个程序
   4. 进程是程序的执行，因此进程组成包括**程序和数据，\**还有记录金衡状态信息的\**「进程控制块」**
7. 进程的特征：动态性（有生命期），并发性，独立性，异步性，结构特征
8. 进程轨迹：某个执行指令的顺序
9. 五状态：运行态；就绪态；阻塞态；新建态；退出态 
   1. 因为处理器比 IO 快得多，为了释放更多内存空间，可能会讲所有进程写入磁盘保存（挂起）
   2. 新增两个状态：阻塞挂起，就绪挂起
   3. 处理器执行进程调度模型（两队列）
10. 四种类型表：内存表、I/O 表、文件表、进程表
11. 进程控制： 
    1. 进程创建：标示号、空间、控制块、连接、数据结构
    2. 何时切换进程：时钟、I/O 中断、内存失效、陷阱、系统调用
    3. 模式切换（用户、系统）：只有操作系统有权；
    4. 进程切换：保存上下文（包括 PC 和寄存器）、更新状态、加入队列、选择另一个进程、更新选择进程状态、更新数据结构、恢复上下文
12. 操作系统的执行：无进程的内核、在用户进程中执行、基于进程的操作系统

## 线程

------

1. 进程特点：资源所有权、调度 / 执行（有存放进程的虚拟地址空间，受保护地访问处理器等其他资源，内部多个线程共享环境）
2. 线程：执行状态（运行、就绪等）、上下文、执行栈、局部变量的静态存储空间、对所属进程的资源的访问【进程终止表明终止其中所有线程】
3. 优点：创建快，终止快，切换快，通信效率高
4. 为什么分离：线程为分离出来的执行体单位，进程退化为资源分配单位和线程的容器（提升效率，减少分配负担）
5. 线程状态：派生、阻塞、接触阻塞、结束
6. 线程的实现分类： 
   1. 用户级线程：线程管理由应用程序完成（优点：节省开销，不会扰乱底层调度，可以在任何操作系统中运行；缺点：如果被阻塞，则所有线程都被阻塞、影响执行速度、不能和其他进程争取 CPU 处理时间）
   2. 内核级多线程：比如 Windows，为每个线程维护上下文，以一个线程为基本单位进行调度（优点：可以把多个线程调度到多个处理器、不会被全部阻塞、内核自身也可以使用多线程；缺点：线程切换需要内核的模式切换、复杂， 操作繁琐）
   3. 组合方法：用户空间完成线程的创建，调度和同步也在应用程序中进行，程序员可以调度线程数目，不会阻塞所有线程
7. 多处理器系统，优点：可靠，高度平行性，提高计算能力（不用增加过多费用），提高处理能力（不必添加额外的系统），灵活性
8. 对称多处理、微内核、Windows 线程（略）

## 并发性：互斥和同步

------

1. 出现在：多个应用程序、结构化应用程序（自身并发）、操作系统
2. 临界区是：进程中访问共享资源的代码段
3. 并发的难点：全局资源共享、最优化管理、定位程序设计
4. 并发中进程相互影响：进程之间的通讯、共享资源、多进程之间的同步、处理器时间分配
5. 概念解释：互斥、同步、死锁、饥饿
6. 互斥： 
   1. 要去：一个进程、非临界区不能干涉、不允许死锁或者饿死、能立即进入、对速度和处理器数目没有要求、停留时间有限
   2. 硬件支持：中断禁止（关中断、进入临界区、开中断） 
      1. 指令：`boolean testset(int i)`
      2. 优点：适用于单处理器或共享内存的多处理器、简单易于证明、支持多个临界区
      3. 缺点：忙等消耗时间，可能饥饿、可能死锁
   3. 信号量技术： 
      1. 操作：初始化、wait、signal（同步原语）
      2. wait 之后的等待分为**阻塞等待**和**忙等待**
      3. OS 规定，同步原语是不可分割的，以保证进程互斥地使用，且不被中断（原子原语）
      4. 保证不可分割的方法：软件互斥（效率低），硬件中断（单 CPU），硬件指令，由硬件 / 固件直接实现同步原语（给原语上锁 `testset(s.flag)`）
      5. 互斥与同步问题本质一致
      6. 生产者 / 消费者问题，无限缓冲区，有限缓冲区（注意代码中 semWait 和 semSignal 的顺序问题）
7. 管程、消息传递、读者-写者问题（略）

## 并发行：死锁和饥饿

------

1. 死锁：一组竞争系统资源或相互通信的进程相互的「永久阻塞」。
2. 资源：可抢占（CPU，主存，硬盘），不可抢占（打印机，读卡机，磁带驱动器）、永久性 & 临时性、共享 & 独享
3. 构成死锁的必要条件：**互斥、占有且等待、非抢占**、循环等待（充要）
4. 资源分配图
5. 死锁预防：预防互斥条件，预防占有且等待（低效：阻塞时间长，不可用资源不能被其他进程使用，不能事先知道需要什么资源），预防非抢占（必须释放最初占用资源，只有容易保存和恢复的情况才好用）。预防循环等待是低效的
6. 死锁避免：动态决策分配请求，是否导致死锁。（需要提前知道所有请求信息） 
   1. 进程启动拒绝：拒绝启动导致死锁的进程
   2. 资源分配拒绝（银行家算法）：（不）安全状态，（不）安全序列，【算法的不足难以预知最大资源需求，进程数目不断变化】
   3. 死锁避免的限制：必须先声明每个进程请求的最大资源、进程是无关的、分配的资源数目固定、占有资源时不能退出
7. 死锁检测：允许进入不安全状态，进入死锁则恢复；特点：算法简单，但频繁的检查会耗费相当多处理器时间 
   1. 死锁恢复：取消所有死锁进程、会滚到检查点、取消到不存在死锁、抢占资源到不会出现死锁。
   2. 哲学家就餐问题（限制四个人进入房间）

## 内存管理

------

1. 内存管理需求：重定位、保护、共享、逻辑组织、物理组织
2. 分区技术： 
   1. 碎念的概念
   2. 固定分区：大小不等 / 大小相等
   3. 动态分区： 
      1. 组织形式：存储分块表，已分/空闲分区表（两个表），空闲存储块链
      2. 分配与回收：紧缩（克服外部碎片）
      3. 放置算法：最差（分配后剩下的分区足够大），最先（缩短分配时间），最佳（碎片最少）
   4. 伙伴系统：二叉树、合并叶节点
3. 重定位： 
   1. 概念：内存空间（物理空间），内存地址（物理地址），程序空间（逻辑空间）
   2. 类型：静态地址重定位（执行前集中完成转换），动态地址重定位
   3. 内存地址 MA = 基地址寄存器 BR + 程序虚地址寄存器 VR（概念：逻辑地址、相对地址、物理地址）
4. 分页：允许存储空间不连续 
   1. 进程（**页**、逻辑页、虚页）→ 内存（**帧**、物理页、实页），一般为 2 的整数次幂
   2. 逻辑地址表示：`(p, d)`，表示**页号**和**页内地址**
   3. 页表：页号到物理块号的映射
   4. 逻辑映射的过程：页号 → 帧号 + 页内偏移地址
5. 分段：类似与分页技术，不同的是使用大小不等的段，消除内部碎片，产生很小的外部碎片 
   1. 简单分段：段 —— 一组逻辑信息的集合
   2. 分页对程序员不可见，而分段通常可见（按照程序的自身逻辑关系，划分为若干个段，比如一个进程分为三段，main 函数、子函数、全局变量）
   3. 概念：段名（程序员指定），段号（也叫内部段名，从 0 开始，OS 指定），段内地址（从 0 开始编号）
   4. 表示方法：地址表示方法： `(s, w)` 即**段号**和**段内地址** [0 - 7][8 - 15][15 - 31] （///，段号 s，段内地址  w）；段表表示方法：[0 - 15][16 - 31]（段长、基址）
   5. 段表：段号、段长、在主存中的起始位置
   6. 注意区别页表和段表的不同

## 虚拟内存

------

本章列出都是考点。

1. 使用原因：基于程序局部性原理，没必要把一个作业一次性装入内存。

2. 特点：空间开销（地址转换表），时间开销，额外 I/O 操作【内存管理单元 MMU，将虚拟地址映射为物理地址】

3. 分块：

   1. 如何实现：主存保留常驻集（需要一直放在内存的部分）；进程执行，如果只访问常驻集，则顺利进行；如果访问不在主存中的逻辑地址，则产生中断，内存访问失效；将进程设为阻塞，并且获得控制，操作系统需要把访问失效的逻辑地址的进程快取进主存（产生 I/O 请求，此时还可以让另一个进程运行）。
   2. 进程分片装入的好处：保留多个进程；进程可以比主存空间还大
   3. 系统抖动：一个块在用之前被扔出去，很快就1不得不取回来

4. 分页 Paging：

   1. 页表项：

      [ P ][ M ][ 其他控制位 ][ 帧号 ]

      （P 表示是否在主存中，M 表示从上一次装入主存是否已经改变，其他控制位提供保护或者共享操作） 

      1. 虚拟地址：**[ 页号 ][ 偏移量 ]**
      2. 页号 → 帧号 + 偏移量 ⇒ 物理地址
      3. 页表项有时会很多，大多数虚拟内存方案，页表都存在虚拟内存中，进程运行时，只有一部分页表在主存中。

5. 两级层次页表等（略）

6. 替换算法：

   1. 最佳策略：替换下次访问距当前时间最长的那些页。（一般作为衡量其他算法的性能）
   2. 最近最少使用：LRU
   3. 先进先出：FIFO
   4. 时钟：增加一个 use 位，新加入设 1，使用后设为 1，找到第一个 0 替换，在找的过程中，1 改为 0

